# Andriy Zhugayevych  azh@ukr.net
# RandomWalk package
# created 13.10.2011  modified - see version below
#
################################################################################
#root: RandomWalk
#hfl: RandomWalk
#toc: _Overview
RandomWalk:=module() option package;

export ModuleLoad, Setup,
       BuildW, BuildA, # Builders
       GreensF, StatSol, ZeroExpan, # Solvers
       Velocity, DiffusionTensor, DiffusionLength; # Infinite periodic lattices

local  version;




ModuleLoad:=proc()
version:=20200727;
# BasicTools package is required
if not(member('BasicTools',packages())) then try with(BasicTools) catch: error "Cannot find the required BasicTools package: %1",lastexception end end;
# Default settings
Setup();
NULL
end:

#hfl: Setup
#toc: _Setup
#RandomWalk[Setup]
Setup:=proc({printout::boolean:=false})
ProcessSetupArgs([_rest],[],['version'])
end:





################################################################################
#cat: Builders


#hfl: BuildW
BuildW:=proc(n::posint,s::{"Matrix","RandomMatrix","Generate","Sample","GamEps"},gen,{sym::boolean:=false})
local W,Gam,Eps,i,j;
if (s="Matrix") then
 W:=Matrix(n,gen,`if`(sym,shape=symmetric,NULL),_rest)
elif (s="RandomMatrix") then
 W:=LinearAlgebra[RandomMatrix](n,'generator'=gen,`if`(sym,shape=symmetric,NULL),_rest)
elif (s="Generate") then
 W:=Matrix(n,RandomTools[Generate](gen,'makeproc'=true),`if`(sym,shape=symmetric,NULL),_rest)
elif (s="Sample") then
 W:=Matrix(n,convert(Statistics[Sample](gen,n^2),list),_rest);
 if sym then W:=Matrix(W,shape=symmetric,_rest) end
elif (s="GamEps") then
 Gam:=Matrix(n,convert(Statistics[Sample](gen[1],n^2),list));
 Eps:=Statistics[Sample](gen[2],n);
 W:=Matrix(n,(i,j)->`if`(i=j,0,exp(Eps[i])*Gam[i,j]),_rest)
end;
for i from 1 to n do W[i,i]:=0 end;
for i from 1 to n do for j from 1 to n do if (W[i,j]<0) then error "W[%1,%2]=%3<0",i,j,W[i,j] end end end;
if (s="GamEps") then W,Gam,Eps else W end
end:


#hfl: BuildA
BuildA:=proc(W::Matrix,U::Vector:=Vector(op(1,W)[1],0),$)
local n;
n:=op(1,W)[1];
Matrix(n,(i,j)->`if`(i=j,-U[i]-add(W[i,k],k=1..n),W[i,j]),shape=MatrixOptions(W,shape),datatype=MatrixOptions(W,datatype))
end:





################################################################################
#cat: Solvers


#hfl: GreensF
GreensF:=proc(s,W::Matrix,U::Vector:=Vector(op(1,W)[1],0),$)
local n,Gi;
n:=op(1,W)[1];
Gi:=Matrix(n,(i,j)->`if`(i=j,s+U[i]+add(W[i,k],k=1..n),-W[i,j]),shape=MatrixOptions(W,shape),datatype=`if`(type(s,float),float,MatrixOptions(W,datatype)));
Gi^(-1)
end:


#hfl: StatSol
StatSol:=proc(W::Matrix,i00::nonnegint:=0,simplifyf::procedure:=simplify,{printout::boolean:=false},$)
local A,params,i0,pi1,C,pi;
A:=BuildA(W);
params:=select(type,indets(A),name);
i0:=`if`(i00=0,op(MinIdx([seq(A[i,i],i=1..op(1,A)[1])])),i00);
pi1:=LinearAlgebra[LinearSolve](LinearAlgebra[Transpose](A[[..i0-1,i0+1..]$2]),LinearAlgebra[Transpose](-A[i0,[..i0-1,i0+1..]]));
C:=`minus`(select(type,indets(pi1),name),params);
if (C<>{}) then pi1:=simplify(subs(seq(v=0,v=C),pi1)) end;
pi:=Vector[row](op(1,pi1)+1,`if`(VectorOptions(pi1,'datatype')=float[8],'datatype'=float,NULL));
pi[i0]:=1;
pi[[..i0-1,i0+1..]]:=pi1;
pi:=LinearAlgebra[Normalize](pi,1);
if (params<>{} or simplifyf<>simplify) then pi:=simplifyf(pi) end;
if (printout and params={}) then printf("Norm(pi.A)= %.1e (L1), %.1e (Linf)\n",LinearAlgebra[Norm](pi.A,1),LinearAlgebra[Norm](pi.A,infinity)) end;
pi
end:

#hfl: StatSol
ZeroExpan:=proc(W::Matrix,i0::nonnegint:=0,{printout::boolean:=false},$)
local dtdecl,pi,n,T,Ti,i,lsi,W2,pi2,R2,R;
dtdecl:=`if`(MatrixOptions(W,'datatype')=float[8],'datatype'=float,NULL);
pi:=StatSol(W,i0,':-printout'=printout);
n:=op(1,pi);
T:=Matrix(n,n-1,(i,j)->`if`(i=j+1,1,0)-pi[j+1],dtdecl);
Ti:=Matrix(n-1,n,dtdecl);
for i from 1 to n-1 do  Ti[i,1]:=-1;  Ti[i,i+1]:=1 end;
try pi,T.LinearAlgebra[MatrixInverse](-Ti.BuildA(W).T).Ti
catch:
 lsi:=[seq(`if`(pi[i]=0,NULL,i),i=1..n)];
 if printout then printf("Singular matrix, will use subspace [%{c,}d%s]\n",Vector(lsi[..min(16,nops(lsi))]),`if`(nops(lsi)>16,",...","")) end;
 W2:=W[lsi,lsi];
 if (add(abs(v),v=W2)=0) then return pi,Matrix(n,dtdecl) end;
 pi2,R2:=ZeroExpan(W2,':-printout'=printout);
 R:=Matrix(n,dtdecl);
 R[lsi,lsi]:=R2;
 pi,R end
end:



################################################################################
#cat: Infinite periodic lattices


#hfl: Velocity
Velocity:=proc( sites::Array, W::Matrix, M::Matrix:=LinearAlgebra[IdentityMatrix](Dim2(sites)[2]), replicas::{'undefined',Vector}:='undefined', { printout::boolean:=false },$)
local n,n2,d,dtdecl,repl,i,pi;
n,n2:=Dim2(W);
d:=Dim2(sites)[2];
dtdecl:=`if`(MatrixOptions(W,datatype)=float or MatrixOptions(W,datatype)[0]=float,datatype=float,NULL);
for i from 1 to n do W[i,i]:=0 end:
if (replicas='undefined') then
 repl:=Vector(n,i->[]):
 for i from 1 to n2 do repl[sites[i,0]]:=[op(repl[sites[i,0]]),i] end
else
 repl:=replicas end;
pi:=StatSol(Matrix(n,(i,j)->`if`(i=j,0,add(W[i,l],l=repl[j])),dtdecl),':-printout'=printout);
Vector[column](pi.Matrix(n,d,(i,o)->add(W[i,j]*sites[j,o],j=1..n2),dtdecl).LinearAlgebra[Transpose](M),dtdecl)
end:


#hfl: Velocity
DiffusionTensor:=proc( sites::Array, W::Matrix, M::Matrix:=LinearAlgebra[IdentityMatrix](Dim2(sites)[2]),
 replicas::{'undefined',Vector}:='undefined', i0::nonnegint:=0, { printout::boolean:=false },$)
local n,n2,d,dtdecl,repl,i,Wp,Wpp,pi,R,uv;
n,n2:=Dim2(W);
d:=Dim2(sites)[2];
dtdecl:=`if`(MatrixOptions(W,datatype)=float or MatrixOptions(W,datatype)[0]=float,datatype=float,NULL);
for i from 1 to n do W[i,i]:=0 end:
if (replicas='undefined') then
 repl:=Vector(n,i->[]):
 for i from 1 to n2 do repl[sites[i,0]]:=[op(repl[sites[i,0]]),i] end
else
 repl:=replicas end;
pi,R:=ZeroExpan(Matrix(n,(i,j)->`if`(i=j,0,add(W[i,l],l=repl[j])),dtdecl),i0,':-printout'=printout);
Wp:=Vector(d,o->Matrix(n,(i,j)->add(W[i,l]*sites[l,o],l=repl[j]),dtdecl));
Wpp:=Matrix(d,(o1,o2)->Matrix(n,(i,j)->add(W[i,l]*sites[l,o1]*sites[l,o2],l=repl[j]),dtdecl));
uv:=Vector(n,1):
Matrix(M.Matrix(d,(o1,o2)->(pi.Wpp[o1,o2].uv+pi.Wp[o1].R.Wp[o2].uv+pi.Wp[o2].R.Wp[o1].uv)/2,shape=symmetric,dtdecl).LinearAlgebra[Transpose](M),shape=symmetric,dtdecl)
end:


#hfl: Velocity
DiffusionLength:=proc( sites::Array, W::Matrix, U::Vector, points::Matrix, M::Matrix:=LinearAlgebra[IdentityMatrix](Dim2(sites)[2]), replicas::{'undefined',Vector}:='undefined', { printout::boolean:=false },$)
local n,n2,d,dtdecl,repl,i,G,Wp,Wpp,Up,Upp,uv;
n,n2:=Dim2(W);
d:=Dim2(sites)[2];
dtdecl:=`if`(MatrixOptions(W,datatype)=float or MatrixOptions(W,datatype)[0]=float,datatype=float,NULL);
for i from 1 to n do W[i,i]:=0 end:
if (replicas='undefined') then
 repl:=Vector(n,i->[]):
 for i from 1 to n2 do repl[sites[i,0]]:=[op(repl[sites[i,0]]),i] end
else
 repl:=replicas end;
G:=GreensF(0,Matrix(n,(i,j)->`if`(i=j,0,add(W[i,l],l=repl[j])),dtdecl),U);
Wp:=Vector(d,o->Matrix(n,(i,j)->add(W[i,l]*sites[l,o],l=repl[j]),dtdecl));
Wpp:=Matrix(d,(o1,o2)->Matrix(n,(i,j)->add(W[i,l]*sites[l,o1]*sites[l,o2],l=repl[j]),dtdecl));
Up:=Vector(d,o->Vector(n,i->U[i]*points[o,i],dtdecl));
Upp:=Matrix(d,(o1,o2)->Vector(n,i->U[i]*points[o1,i]*points[o2,i],dtdecl));
uv:=Vector(n,1):
Vector(n,i->Matrix(M.Matrix(d,(o1,o2)->G[i,..].(Wpp[o1,o2].uv+Wp[o1].G.Wp[o2].uv+Wp[o2].G.Wp[o1].uv+Wp[o1].G.Up[o2]+Wp[o2].G.Up[o1]+Upp[o1,o2])/2,shape=symmetric,dtdecl).LinearAlgebra[Transpose](M),shape=symmetric,dtdecl))
end:





########################################################################

ModuleLoad()

end module:
